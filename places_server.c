/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "places.h"
#include "airports.h"
#include <errno.h>
#include <stdio.h>
#include <string.h>

#define ALPHA_SIZE 26
#define STATE_ARRAY_SIZE 60
#define PLACE_ARRAY_SIZE 200
#define STATE_SIZE 3
#define CITY_SIZE 40
#define LAT_SIZE 11
#define LON_SIZE 12

const char letters[ALPHA_SIZE] = {'a','b','c','d','e','f','g','h','i','j','k',
								  'l','m','n','o','p','q','r','s','t','u','v',
								  'w','x','y','z'};
struct AlphaNode{
  int currentIndex;
  placeData arr[PLACE_ARRAY_SIZE];
};

struct StateNode{
  char* stateCode;
  AlphaNode arr[ALPHA_SIZE];
};

FILE *fp;
char buff[255]; //holds a line of the file
StateNode Array[STATE_ARRAY_SIZE]; 
int lastIndex; //current "last" index in StateNode Array
int begin = 0;

//returns all lowercase string
char* lower(char* c)
{
  char* temp = strdup(c);
  int count = 0;

  while(temp[count] != '\0'){
	temp[count] = tolower(temp[count]);
	count++;
  }

  return temp;
}

void swap(int i1, int i2)
{
  StateNode temp;
  int count = 0;
  int count2 = 0; 
  
  //copy first state to temp
  temp.stateCode = Array[i1].stateCode; 
  
  while(count < ALPHA_SIZE){
	temp.arr[count].currentIndex = Array[i1].arr[count].currentIndex;
	while(count2 < PLACE_ARRAY_SIZE){
	  temp.arr[count].arr[count2].cityName = Array[i1].arr[count].arr[count2].cityName;
	  temp.arr[count].arr[count2].stateCode = Array[i1].arr[count].arr[count2].stateCode;
	  temp.arr[count].arr[count2].lat = Array[i1].arr[count].arr[count2].lat;
	  temp.arr[count].arr[count2].lon = Array[i1].arr[count].arr[count2].lon;
	  count2++;
	}
	count2 = 0;
	count++;
  }

  //copy second state to first state index
  count = 0;
  count2 = 0;

  Array[i1].stateCode = Array[i2].stateCode; 
    
  while(count < ALPHA_SIZE){
	Array[i1].arr[count].currentIndex = Array[i2].arr[count].currentIndex;
	while(count2 < PLACE_ARRAY_SIZE){
	  Array[i1].arr[count].arr[count2].cityName = Array[i2].arr[count].arr[count2].cityName;
	  Array[i1].arr[count].arr[count2].stateCode = Array[i2].arr[count].arr[count2].stateCode;
	  Array[i1].arr[count].arr[count2].lat = Array[i2].arr[count].arr[count2].lat;
	  Array[i1].arr[count].arr[count2].lon = Array[i2].arr[count].arr[count2].lon;
	  count2++; 
	}
	count2 = 0;
	count++;
  }
  
  //copy temp to second state index
  count = 0;
  count2 = 0;
  Array[i2].stateCode = temp.stateCode; 

  while(count < ALPHA_SIZE){
	Array[i2].arr[count].currentIndex = temp.arr[count].currentIndex;
	while(count2 < PLACE_ARRAY_SIZE){
	  Array[i2].arr[count].arr[count2].cityName = temp.arr[count].arr[count2].cityName;
	  Array[i2].arr[count].arr[count2].stateCode = temp.arr[count].arr[count2].stateCode;
	  Array[i2].arr[count].arr[count2].lat = temp.arr[count].arr[count2].lat;
	  Array[i2].arr[count].arr[count2].lon = temp.arr[count].arr[count2].lon;
	  count2++;
	}
	count2 = 0;
	count++;
  }
}

void stateSort()
{  
  int count = 0,count2;
  
  while(count < lastIndex+1){
	count2 = count-1;
	
	while (count2 >= 0 && strcmp(Array[count2].stateCode,Array[count].stateCode) > 0){
	  swap(count2+1,count2);
	  count2 = count2--;
	}
	swap(count2+1,count);
	count++;
  }
}

/* READFILE FUNCTION
 *
 * Reads file line by line and places data in data structure
 *
 * Uses a 3-d array to keep track of all the data
 *   - First layer: all the state codes (StateNode)
 *   - Second layer: all the letters the cities could start with (alphaNode)
 *   - Third layer: all the cities (placeData)
 */
void readFile(char *fileName)
{
  char state[STATE_SIZE];
  char city[CITY_SIZE];
  char lat[LAT_SIZE];
  char lon[LON_SIZE];
  int index = -1;
  char *currentState = "";

  fp = fopen(fileName, "r");

  if (fp == NULL){
	perror("Error opening file");
	return;
  }

  while (fgets(buff, 255, fp) != NULL){

	//grabs state code from buff
	strncpy(state,strdup(buff),STATE_SIZE-1);
	state[STATE_SIZE-1] = '\0';
	//printf("%s\n",state);
	
	//grabs full place name from buff
	strncpy(city,strdup(buff + 9),CITY_SIZE-1);
	city[CITY_SIZE-1] = '\0';
	//printf("%s\n",city); 
	
	//grabs latitude from buff
	strncpy(lat,strdup(buff + 143),LAT_SIZE-1);
	lat[LAT_SIZE-1] = '\0';
	//printf("%s\n",lat); 
	
	//grabs longitude from buff
	strncpy(lon,strdup(buff + 153),LON_SIZE-1);
	lon[LON_SIZE-1] = '\0';
	//printf("%s\n",lon);
	
	//if there is a new state, start on next element in array
	if (strcmp(currentState,state) != 0){
	  currentState = strdup(state);
	  //printf("%s\n",state);
	  index++;
	  Array[index].stateCode = strdup(state);
	}

	//finds the letter array for the city
	int count = 0;
	while (count < ALPHA_SIZE && tolower(city[0]) != letters[count])
	  count++;

	//index of the placeData struct
	int temp = Array[index].arr[count].currentIndex;

	//updates data fields at placeData struct at index
	Array[index].arr[count].arr[temp].stateCode = strdup(state);
	Array[index].arr[count].arr[temp].cityName = strdup(city);
	Array[index].arr[count].arr[temp].lat = atof(lat);
	Array[index].arr[count].arr[temp].lon = atof(lon);
	Array[index].arr[count].currentIndex++;

  }
  lastIndex = index;

  //sort states in ascending order based on codes
  stateSort(); 
	
  fclose(fp);
}

/* FINDCOORDS FUNCTION
 *
 * Finds the longitude and latitude of the given location
 *
 * Return Values:
 *   [-1]: Place not found
 *    [0]: Locations found, coordinates returned
 *    [1]: Prefix matches multiple places
 */
int findCoords(coordinatesA* temp, location l)
{
  int found = 0;
  int first = 0;
  int last = lastIndex;
  int mid;
  char* city = l.cityName;
  char* state = l.stateCode;
  int sDex; //state index
  int aDex; //starting letter index
  int cDex; //city index

  //binary search to find state name
  while(first <= last && found == 0){
   
	mid = (first + last)/2;
	
	if (strcmp(Array[mid].stateCode, state) == 0){
	  sDex = mid;
	  found = 1;
	}else if(strcmp(Array[mid].stateCode, state) > 0){
	  last = mid - 1;
	}else if(strcmp(Array[mid].stateCode, state) < 0){
	  first = mid + 1;
	  }
  }

  //binary search to find starting letter
  if(found == 1){ 
	first = 0;
	last = ALPHA_SIZE;
	found = 0;
	char letter = tolower(city[0]); //starting letter of city

	while(first <= last && found == 0){
	  mid = (first + last)/2;

	  if (letters[mid] == letter){
		aDex = mid;
		found = 1;
	  }else if(letters[mid] > letter){
		last = mid - 1;
	  }else if(letters[mid] < letter){
		first = mid + 1;
	  }
	}
  }else{
	return -1;
  }

  //binary search to find a city that matches
  if(found == 1){ 
	first = 0;
	last = Array[sDex].arr[aDex].currentIndex;
	found = 0;
	char* c;

	while(first <= last && found == 0){
	  mid = (first + last)/2;

	  c = Array[sDex].arr[aDex].arr[mid].cityName;

	  if (strncmp(lower(c),lower(city),strlen(city)) == 0){
		cDex = mid;
		found = 1;
	  }else if(strncmp(lower(c),lower(city),strlen(city)) > 0){
		last = mid - 1;
	  }else if(strncmp(lower(c),lower(city),strlen(city)) < 0){
		first = mid + 1;
	  }
	}
  }else{
	return -1;
  }

  //if match, check surrounding cities (+1, -1) for same prefix
  if (found == 1){
	found = 0;
	AlphaNode* a = &Array[sDex].arr[aDex];

	if((cDex+1) >=  0 && (cDex+1) <= a->currentIndex){
	  if (strncmp(lower(a->arr[cDex+1].cityName),lower(city),strlen(city)) == 0)
		found = 1;
	}else if((cDex-1) >= 0 && (cDex-1) <= a->currentIndex){
	  if (strncmp(lower(a->arr[cDex-1].cityName),lower(city),strlen(city)) == 0)
		found = 1;
	}

	//if there is an ambiguity
	if (found == 1){
	  return 1;
	}else{
	  //returns coordinates
	  temp->lat = a->arr[cDex].lat;
	  temp->lon = a->arr[cDex].lon;
	  return 0;
	}
  }else{
	//if city was not found
	return -1;
  }

}

findplace_ret *findplace_1_svc(location *argp, struct svc_req *rqstp)
{
	static findplace_ret  result;
	CLIENT *clnt;
	findair_ret  *result_1;
	coordinatesA  findairport_1_arg;
	char* host = "localhost";

	if (begin == 0){
	  readFile("places2k.txt");
	  begin = 1;
	}

	int status = findCoords(&findairport_1_arg,*argp);

	printf("%s, %s: %f,%f\n",argp->cityName,argp->stateCode,findairport_1_arg.lat, findairport_1_arg.lon);
	
	xdr_free((xdrproc_t)xdr_findplace_ret, (char *)&result);

	if (status == 0){
#ifndef DEBUG
	  clnt = clnt_create (host, AIRPORTSERVER, AIR_VERS, "udp");

	  if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	  }
#endif

	  result_1 = findairport_1(&findairport_1_arg, clnt);

	  if (result_1 == (findair_ret *) NULL) {
		clnt_perror (clnt, "call failed");
	  }

	  airportList l;
	  aList a;
	  aList* ap = &result.findplace_ret_u.list;

	  for(l = result_1->findair_ret_u.list; l != NULL; l = l->next){
		a = (aData *) malloc(sizeof(aData));

		a->airportName = l->airportName;
		a->airportCode = l->airportCode;
		a->lat = l->lat;
		a->lon = l->lon;
		a->distance = l->distance;
		a->next = NULL;
		*ap = a;
		ap = &a->next;
	  }
	  
	  result.err = 0;
	  
#ifndef DEBUG
	  clnt_destroy (clnt);
#endif
	}else if (status == 1){
	  result.err = 1;
	}else if (status == -1){
	  result.err = -1;
	}
	  
	return &result;
}
